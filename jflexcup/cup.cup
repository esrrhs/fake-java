package fakescript;

import java_cup.runtime.*;
import fakescript.syntree.*;

parser code {:
  private mycup m_mycup;
  public void set_mycup(mycup mc)
  {
	m_mycup = mc;
  }
:};

/* Terminals (tokens returned by the scanner). */
terminal VAR_BEGIN;
terminal RETURN;
terminal BREAK;
terminal FUNC;
terminal WHILE;
terminal FTRUE;
terminal FFALSE;
terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal STRING_DEFINITION;
terminal IDENTIFIER;
terminal NUMBER;
terminal SINGLE_LINE_COMMENT;
terminal DIVIDE_MOD;
terminal ARG_SPLITTER;
terminal PLUS;
terminal MINUS;
terminal DIVIDE;
terminal MULTIPLY;
terminal ASSIGN;
terminal MORE;
terminal LESS;
terminal MORE_OR_EQUAL;
terminal LESS_OR_EQUAL;
terminal EQUAL;
terminal NOT_EQUAL;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal AND;
terminal OR;
terminal FKFLOAT;
terminal PLUS_ASSIGN, MINUS_ASSIGN, DIVIDE_ASSIGN, MULTIPLY_ASSIGN, DIVIDE_MOD_ASSIGN;
terminal COLON;
terminal FOR;
terminal INC;
terminal FAKE;
terminal FKUUID;
terminal OPEN_SQUARE_BRACKET;
terminal CLOSE_SQUARE_BRACKET;
terminal FCONST;
terminal PACKAGE;
terminal INCLUDE;
terminal IDENTIFIER_DOT;
terminal IDENTIFIER_POINTER;
terminal STRUCT;
terminal IS, NOT, CONTINUE;
terminal YIELD, SLEEP;
terminal SWITCH, CASE, DEFAULT;
terminal NEW_ASSIGN;
terminal ELSEIF;
terminal RIGHT_POINTER;
terminal STRING_CAT;
terminal OPEN_BIG_BRACKET;
terminal CLOSE_BIG_BRACKET;

/* Non-terminals */
non terminal program;
non terminal break, continue;
non terminal function_declaration;
non terminal block;
non terminal stmt;
non terminal while_stmt;
non terminal else_stmt;
non terminal elseif_stmt;
non terminal elseif_stmt_list;
non terminal if_stmt;
non terminal cmp;
non terminal body;
non terminal return_stmt;
non terminal return_value;
non terminal return_value_list;
non terminal explicit_value;
non terminal variable;
non terminal arg_expr;
non terminal expr;
non terminal math_expr;
non terminal function_call;
non terminal var;
non terminal arg;
non terminal function_call_arguments;
non terminal function_declaration_arguments;
non terminal assign_stmt;
non terminal cmp_value;
non terminal assign_value;
non terminal expr_value;
non terminal math_assign_stmt;
non terminal for_stmt;
non terminal for_loop_stmt;
non terminal multi_assign_stmt;
non terminal var_list;
non terminal fake_call_stmt;
non terminal struct_mem_declaration, struct_head, struct_define;
non terminal sleep;
non terminal yield;
non terminal switch_stmt;
non terminal switch_case_define;
non terminal switch_case_list;
non terminal const_map_list_value;
non terminal const_map_value;
non terminal const_array_list_value;
non terminal package_head, include_define, include_head;
non terminal const_head, const_define;

/* Precedences */
precedence left PLUS, MINUS;
precedence left DIVIDE, MULTIPLY, DIVIDE_MOD;
precedence left STRING_CAT;

/* Top level rules */
program ::= package_head
	include_head
	struct_head
	const_head
	body
	;
	
body ::=
	/* empty */
	{:
	:}
	|
	function_declaration
	|
	body function_declaration
	;

function_declaration ::=
	FUNC IDENTIFIER:e OPEN_BRACKET function_declaration_arguments:e1 CLOSE_BRACKET block:e2 END:e3
	{:
		types.log("[CUP]: FUNC IDENTIFIER OPEN_BRACKET function_declaration_arguments CLOSE_BRACKET block END");
		func_desc_node p = new func_desc_node();
		p.m_funcname = e.toString();
		p.m_arglist = (func_desc_arglist_node)e1;
		p.m_block = (block_node)e2;
		p.m_endline = ((javasymbol)e3).getLine();
		m_mycup.dd_func_desc(p);
	:}
	|
	FUNC IDENTIFIER:e OPEN_BRACKET function_declaration_arguments:e1 CLOSE_BRACKET END:e3
	{:
		types.log("[CUP]: FUNC IDENTIFIER OPEN_BRACKET function_declaration_arguments CLOSE_BRACKET END");
		func_desc_node p = new func_desc_node();
		p.m_funcname = e.toString();
		p.m_arglist = (func_desc_arglist_node)e1;
		p.m_endline = ((javasymbol)e3).getLine();
		m_mycup.dd_func_desc(p);
	:}
	;

function_declaration_arguments ::=
	/* empty */
	{:
		types.log("[CUP]: empty");
	:}
	| 
	function_declaration_arguments:e ARG_SPLITTER arg:e1 
	{:
		types.log("[CUP]: function_declaration_arguments ARG_SPLITTER arg ");
		func_desc_arglist_node p = (func_desc_arglist_node)e;
		p.add_arg((syntree_node)e1);
		RESULT = p;
	:}
	| 
	arg:e
	{:
		types.log("[CUP]: arg");
		func_desc_arglist_node p = new func_desc_arglist_node();
		p.add_arg((syntree_node)e);
		RESULT = p;
	:}
	;

arg ::=
	IDENTIFIER:e
	{:
		types.log("[CUP]: IDENTIFIER");
		identifier_node p = new identifier_node();
		p.m_str = e.toString();
		RESULT = p;
	:}
	;
	
	
function_call ::=
	IDENTIFIER:e OPEN_BRACKET function_call_arguments:e1 CLOSE_BRACKET 
	{:
		types.log("[CUP]: IDENTIFIER OPEN_BRACKET function_call_arguments CLOSE_BRACKET ");
		function_call_node p = new function_call_node();
		p.m_fuc = e.toString();
		p.m_arglist = (function_call_arglist_node)e1;
		p.m_fakecall = false;
		p.m_classmem_call = false;
		RESULT = p;
	:} 
	|
	IDENTIFIER_DOT OPEN_BRACKET:e function_call_arguments:e1 CLOSE_BRACKET 
	{:
		types.log("[CUP]: IDENTIFIER_DOT OPEN_BRACKET function_call_arguments CLOSE_BRACKET ");
		function_call_node p = new function_call_node();
		p.m_fuc = e.toString();
		p.m_arglist = (function_call_arglist_node)e1;
		p.m_fakecall = false;
		p.m_classmem_call = false;
		RESULT = p;
	:} 
	|
	variable:e COLON IDENTIFIER:e1 OPEN_BRACKET function_call_arguments:e2 CLOSE_BRACKET 
	{:
		types.log("[CUP]: variable COLON IDENTIFIER OPEN_BRACKET function_call_arguments CLOSE_BRACKET ");
		function_call_node p = new function_call_node();
		p.m_fuc = e1.toString();
		p.m_arglist = (function_call_arglist_node)e2;
		if (p.m_arglist == null)
		{
			p.m_arglist = new function_call_arglist_node();
		}
		p.m_arglist.add_arg((syntree_node)e);
		p.m_fakecall = false;
		p.m_classmem_call = true;
		RESULT = p;
	:} 
	;
	
function_call_arguments ::=
	/* empty */
	{:
		types.log("[CUP]: empty ");
	:}
	| 
	function_call_arguments:e ARG_SPLITTER arg_expr:e1
	{:
		types.log("[CUP]: function_call_arguments ARG_SPLITTER arg_expr ");
		function_call_arglist_node p = (function_call_arglist_node)e;
		p.add_arg((syntree_node)e1);
		RESULT = p;
	:}
	| 
	arg_expr:e
	{:
		types.log("[CUP]: arg_expr ");
		function_call_arglist_node p = new function_call_arglist_node();
		p.add_arg((syntree_node)e);
		RESULT = p;
	:}
	;  

arg_expr ::=
	expr_value
	{:
		types.log("[CUP]: expr_value");
	:}
	;

/* function declaration end */

block ::=
	block stmt 
	{:
		types.log("[CUP]: block stmt ");
	:}
	|
	stmt 
	{:
		types.log("[CUP]: stmt");
	:}
	;
  
stmt ::=
	while_stmt
	{:
		types.log("[CUP]: while_stmt");
	:}
	|
	if_stmt
	{:
		types.log("[CUP]: if_stmt");
	:}
	|
	return_stmt
	{:
		types.log("[CUP]: return_stmt");
	:}
	|
	assign_stmt
	{:
		types.log("[CUP]: assign_stmt");
	:}
	|
	multi_assign_stmt
	{:
		types.log("[CUP]: multi_assign_stmt");
	:}
	|
	break
	{:
		types.log("[CUP]: break");
	:}
	|
	continue
	{:
		types.log("[CUP]: continue");
	:}
	|
	expr
	{:
		types.log("[CUP]: expr");
	:}
	|
	math_assign_stmt
	{:
		types.log("[CUP]: math_assign_stmt");
	:}
	|
	for_stmt
	{:
		types.log("[CUP]: for_stmt");
	:}
	|
	for_loop_stmt
	{:
		types.log("[CUP]: for_loop_stmt");
	:}
	|
	fake_call_stmt
	{:
		types.log("[CUP]: fake_call_stmt");
	:}
	|
	sleep
	{:
		types.log("[CUP]: sleep_stmt");
	:}
	|
	yield
	{:
		types.log("[CUP]: yield_stmt");
	:}
	|
	switch_stmt
	{:
		types.log("[CUP]: switch_stmt");
	:}
	;

fake_call_stmt ::=
	FAKE function_call
	{:
		types.log("[CUP]: FAKE function_call");
	:}
	;
	
for_stmt ::=
	FOR block ARG_SPLITTER cmp ARG_SPLITTER block THEN block END
	{:
		types.log("[CUP]: FOR block ARG_SPLITTER cmp ARG_SPLITTER block THEN block END");
	:}
	|
	FOR block ARG_SPLITTER cmp ARG_SPLITTER block THEN END
	{:
		types.log("[CUP]: FOR block ARG_SPLITTER cmp ARG_SPLITTER block THEN END");
	:}
	;

for_loop_stmt ::=
	FOR var ASSIGN assign_value RIGHT_POINTER cmp_value ARG_SPLITTER expr_value THEN block END
	{:
		types.log("[CUP]: FOR var ASSIGN assign_value RIGHT_POINTER cmp_value ARG_SPLITTER expr_value THEN block END");
	:}
	|
	FOR var ASSIGN assign_value RIGHT_POINTER cmp_value ARG_SPLITTER expr_value THEN END
	{:
		types.log("[CUP]: FOR var ASSIGN assign_value RIGHT_POINTER cmp_value ARG_SPLITTER expr_value THEN END");
	:}
	;
	
while_stmt ::=
	WHILE cmp THEN block END 
	{:
		types.log("[CUP]: WHILE cmp THEN block END ");
	:}
	|
	WHILE cmp THEN END 
	{:
		types.log("[CUP]: WHILE cmp THEN END ");
	:}
	;
	
if_stmt ::=
	IF cmp THEN block elseif_stmt_list else_stmt END
	{:
		types.log("[CUP]: IF cmp THEN block elseif_stmt_list else_stmt END");
	:}
	|
	IF cmp THEN elseif_stmt_list else_stmt END
	{:
		types.log("[CUP]: IF cmp THEN elseif_stmt_list else_stmt END");
	:}
	;
	
elseif_stmt_list ::=
	/* empty */
	{:
		types.log("[CUP]: empty");
	:}
	| 
	elseif_stmt_list elseif_stmt
	{:
		types.log("[CUP]: elseif_stmt_list elseif_stmt");
	:}
	| 
	elseif_stmt
	{:
		types.log("[CUP]: elseif_stmt");
	:}
	;
	
elseif_stmt ::=
	ELSEIF cmp THEN block
	{:
		types.log("[CUP]: ELSEIF cmp THEN block");
	:}
	|
	ELSEIF cmp THEN
	{:
		types.log("[CUP]: ELSEIF cmp THEN");
	:}
	;
	
else_stmt ::=
	/*empty*/
	{:
		types.log("[CUP]: empty");
	:}
	|
	ELSE block
	{:
		types.log("[CUP]: ELSE block");
	:}
	|
	ELSE
	{:
		types.log("[CUP]: ELSE");
	:}
	;

cmp ::=
	OPEN_BRACKET cmp CLOSE_BRACKET
	{:
		types.log("[CUP]: OPEN_BRACKET cmp CLOSE_BRACKET");
	:}
	|
	cmp AND cmp
	{:
		types.log("[CUP]: cmp AND cmp");
	:}
	|
	cmp OR cmp
	{:
		types.log("[CUP]: cmp OR cmp");
	:}
	|
	cmp_value LESS cmp_value
	{:
		types.log("[CUP]: cmp_value LESS cmp_value");
	:}
	|
	cmp_value MORE cmp_value
	{:
		types.log("[CUP]: cmp_value MORE cmp_value");
	:}
	|
	cmp_value EQUAL cmp_value
	{:
		types.log("[CUP]: cmp_value EQUAL cmp_value");
	:}
	|
	cmp_value MORE_OR_EQUAL cmp_value
	{:
		types.log("[CUP]: cmp_value MORE_OR_EQUAL cmp_value");
	:}
	|
	cmp_value LESS_OR_EQUAL cmp_value
	{:
		types.log("[CUP]: cmp_value LESS_OR_EQUAL cmp_value");
	:}
	|
	cmp_value NOT_EQUAL cmp_value
	{:
		types.log("[CUP]: cmp_value NOT_EQUAL cmp_value");
	:}
	|
	FTRUE
	{:
		types.log("[CUP]: FTRUE");
	:}
	|
	FFALSE
	{:
		types.log("[CUP]: FFALSE");
	:}
	|
	IS cmp_value
	{:
		types.log("[CUP]: IS cmp_value");
	:}
	|
	NOT cmp_value
	{:
		types.log("[CUP]: NOT cmp_value");
	:}
	;

cmp_value ::=
	explicit_value
	{:
		types.log("[CUP]: explicit_value");
	:}
	|
	variable
	{:
		types.log("[CUP]: variable");
	:}
	|
	expr
	{:
		types.log("[CUP]: expr");
	:}
	;
	
return_stmt ::=
	RETURN return_value_list
	{:
		types.log("[CUP]: RETURN return_value_list");
	:}
	|
	RETURN
	{:
		types.log("[CUP]: RETURN");
	:}
	;
 
return_value_list ::=
	return_value_list ARG_SPLITTER return_value
	{:
		types.log("[CUP]: return_value_list ARG_SPLITTER return_value");
	:}
	|
	return_value
	{:
		types.log("[CUP]: return_value");
	:}
	;
 
return_value ::=
	explicit_value
	{:
		types.log("[CUP]: explicit_value");
	:}
	|
	variable
	{:
		types.log("[CUP]: variable");
	:}
	|
	expr
	{:
		types.log("[CUP]: expr");
	:}
	;

assign_stmt ::=
	var ASSIGN assign_value
	{:
		types.log("[CUP]: var ASSIGN assign_value");
	:}
	|
	var NEW_ASSIGN assign_value
	{:
		types.log("[CUP]: var NEW_ASSIGN assign_value");
	:}
	;

multi_assign_stmt ::=
	var_list ASSIGN function_call
	{:
		types.log("[CUP]: var_list ASSIGN function_call");
	:}
	|
	var_list NEW_ASSIGN function_call
	{:
		types.log("[CUP]: var_list NEW_ASSIGN function_call");
	:}
	;
	
var_list ::=
	var_list ARG_SPLITTER var
	{:
		types.log("[CUP]: var_list ARG_SPLITTER var");
	:}
	|
	var
	{:
		types.log("[CUP]: var");
	:}
	;
	
assign_value ::=
	explicit_value
	{:
		types.log("[CUP]: explicit_value");
	:}
	|
	variable
	{:
		types.log("[CUP]: variable");
	:}
	|
	expr
	{:
		types.log("[CUP]: expr");
	:}
	;
	
math_assign_stmt ::=
	variable PLUS_ASSIGN assign_value
	{:
		types.log("[CUP]: variable PLUS_ASSIGN assign_value");
	:}
	|
	variable MINUS_ASSIGN assign_value
	{:
		types.log("[CUP]: variable MINUS_ASSIGN assign_value");
	:}
	|
	variable DIVIDE_ASSIGN assign_value
	{:
		types.log("[CUP]: variable DIVIDE_ASSIGN assign_value");
	:}
	|
	variable MULTIPLY_ASSIGN assign_value
	{:
		types.log("[CUP]: variable MULTIPLY_ASSIGN assign_value");
	:}
	|
	variable DIVIDE_MOD_ASSIGN assign_value
	{:
		types.log("[CUP]: variable DIVIDE_MOD_ASSIGN assign_value");
	:}
	|
	variable INC
	{:
		types.log("[CUP]: variable INC");
	:}
	;
	
var ::=
	VAR_BEGIN IDENTIFIER
	{:
		types.log("[CUP]: VAR_BEGIN IDENTIFIER");
	:}
	|
	variable
	{:
		types.log("[CUP]: variable");
	:}
	;

variable ::=
	IDENTIFIER
	{:
		types.log("[CUP]: IDENTIFIER");
	:}
	|
	IDENTIFIER OPEN_SQUARE_BRACKET expr_value CLOSE_SQUARE_BRACKET
	{:
		types.log("[CUP]: IDENTIFIER OPEN_SQUARE_BRACKET expr_value CLOSE_SQUARE_BRACKET");
	:}
	|
	IDENTIFIER_POINTER
	{:
		types.log("[CUP]: IDENTIFIER_POINTER");
	:}
	|
	IDENTIFIER_DOT
	{:
		types.log("[CUP]: IDENTIFIER_DOT");
	:}
	;

expr ::=
	OPEN_BRACKET expr CLOSE_BRACKET
	{:
		types.log("[CUP]: OPEN_BRACKET expr CLOSE_BRACKET");
	:}
	|
	function_call
	{:
		types.log("[CUP]: function_call");
	:}
	|
	math_expr
	{:
		types.log("[CUP]: math_expr");
	:}
	;

math_expr ::=
	OPEN_BRACKET math_expr CLOSE_BRACKET
	{:
		types.log("[CUP]: OPEN_BRACKET math_expr CLOSE_BRACKET");
	:}
	|
	expr_value PLUS expr_value
	{:
		types.log("[CUP]: expr_value PLUS expr_value");
	:}
	|
	expr_value MINUS expr_value
	{:
		types.log("[CUP]: expr_value MINUS expr_value");
	:}
	|
	expr_value MULTIPLY expr_value
	{:
		types.log("[CUP]: expr_value MULTIPLY expr_value");
	:}
	|
	expr_value DIVIDE expr_value
	{:
		types.log("[CUP]: expr_value DIVIDE expr_value");
	:}
	|
	expr_value DIVIDE_MOD expr_value
	{:
		types.log("[CUP]: expr_value DIVIDE_MOD expr_value");
	:}
	|
	expr_value STRING_CAT expr_value
	{:
		types.log("[CUP]: expr_value STRING_CAT expr_value");
	:}
	;	

expr_value ::=
	math_expr
	{:
		types.log("[CUP]: math_expr");
	:}
	|
	explicit_value
	{:
		types.log("[CUP]: explicit_value");
	:}
	|
	function_call
	{:
		types.log("[CUP]: function_call");
	:}
	|
	variable
	{:
		types.log("[CUP]: variable");
	:}
	;
	
break ::=
	BREAK 
	{:
		types.log("[CUP]: BREAK");
	:}
	;
	
continue ::=
	CONTINUE 
	{:
		types.log("[CUP]: CONTINUE");
	:}
	;

sleep ::=
	SLEEP expr_value 
	{:
		types.log("[CUP]: SLEEP");
	:}
	;
	
yield ::=
	YIELD expr_value
	{:
		types.log("[CUP]: YIELD");
	:}
	;
	
switch_stmt ::=
	SWITCH cmp_value switch_case_list DEFAULT block END
	{:
		types.log("[CUP]: SWITCH cmp_value switch_case_list DEFAULT block END");
	:}
	|
	SWITCH cmp_value switch_case_list DEFAULT END
	{:
		types.log("[CUP]: SWITCH cmp_value switch_case_list DEFAULT END");
	:}
	;
	
switch_case_list ::=
	switch_case_define
	{:
		types.log("[CUP]: switch_case_define");
	:}
	|
	switch_case_list switch_case_define
	{:
		types.log("[CUP]: switch_case_list switch_case_define");
	:}
	;

switch_case_define ::=
	CASE cmp_value THEN block
	{:
		types.log("[CUP]: CASE cmp_value THEN block");
	:}
	|
	CASE cmp_value THEN
	{:
		types.log("[CUP]: CASE cmp_value THEN");
	:}
	;
		
package_head ::=
	/* empty */
	{:
	:}
	|
	PACKAGE IDENTIFIER:e
	{:
		types.log("[CUP]: PACKAGE IDENTIFIER ");
		m_mycup.set_package(e.toString());
	:}
	|
	PACKAGE IDENTIFIER_DOT:e
	{:
		types.log("[CUP]: PACKAGE IDENTIFIER_DOT ");
		m_mycup.set_package(e.toString());
	:}
	;

include_head ::=
	/* empty */
	{:
	:}
	|
	include_define
	|
	include_head include_define
	;
	
include_define ::=
	INCLUDE STRING_DEFINITION:e
	{:
		types.log("[CUP]: INCLUDE STRING_DEFINITION ");
		m_mycup.add_include(e.toString());
	:}
	;

struct_head ::=
	/* empty */
	{:
	:}
	|
	struct_define
	|
	struct_head struct_define
	;

struct_define ::=
	STRUCT IDENTIFIER:e struct_mem_declaration END
	{:
		types.log("[CUP]: STRUCT IDENTIFIER struct_mem_declaration END ");
		m_mycup.add_struct_desc(e.toString());
	:}
	;
	
struct_mem_declaration ::=
	struct_mem_declaration IDENTIFIER:e
	{:
		types.log("[CUP]: struct_mem_declaration IDENTIFIER ");
	:}
	| 
	IDENTIFIER:e
	{:
		types.log("[CUP]: IDENTIFIER ");
	:}
	;

const_head ::=
	/* empty */
	{:
	:}
	|
	const_define
	|
	const_head const_define
	;

const_define ::=
	FCONST IDENTIFIER:e ASSIGN explicit_value:e1
	{:
		types.log("[CUP]: FCONST IDENTIFIER ASSIGN explicit_value ");
		m_mycup.add_const_desc(e.toString(), (syntree_node)e1);
	:}
	;

explicit_value ::=
	FTRUE:e
	{:
		types.log("[CUP]: FTRUE ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_TRUE;
		RESULT = p;
	:}
	|
	FFALSE:e
	{:
		types.log("[CUP]: FFALSE ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_FALSE;
		RESULT = p;
	:}
	|
	NUMBER:e 
	{:
		types.log("[CUP]: NUMBER ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_NUM;
		RESULT = p;
	:}
	|
	FKUUID:e
	{:
		types.log("[CUP]: FKUUID ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_UUID;
		RESULT = p;
	:}
	|
	STRING_DEFINITION:e 
	{:
		types.log("[CUP]: STRING_DEFINITION ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_STR;
		RESULT = p;
	:}
	|
	FKFLOAT:e
	{:
		types.log("[CUP]: FKFLOAT ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_FLOAT;
		RESULT = p;
	:}
	|
	OPEN_BIG_BRACKET const_map_list_value:e CLOSE_BIG_BRACKET
	{:
		types.log("[CUP]: OPEN_BIG_BRACKET const_map_list_value CLOSE_BIG_BRACKET ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_MAP;
		p.m_v = (const_map_list_value_node)e;
		RESULT = p;
	:}
	|
	OPEN_SQUARE_BRACKET const_array_list_value:e CLOSE_SQUARE_BRACKET
	{:
		types.log("[CUP]: OPEN_BIG_BRACKET const_array_list_value CLOSE_BIG_BRACKET ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_ARRAY;
		p.m_v = (const_array_list_value_node)e;
		RESULT = p;
	:}
	;
 

const_map_list_value ::=
	/* empty */
	{:
		types.log("[CUP]: empty ");
		const_map_list_value_node p = new const_map_list_value_node();
		RESULT = p;
	:}
	|
	const_map_value:e
	{:
		types.log("[CUP]: const_map_value ");
		const_map_list_value_node p = new const_map_list_value_node();
		p.add_ele((const_map_value_node)e);
		RESULT = p;
	:}
	|
	const_map_list_value:e const_map_value:e1
	{:
		types.log("[CUP]: const_map_list_value const_map_value ");
		const_map_list_value_node p = (const_map_list_value_node)e;
		p.add_ele((const_map_value_node)e1);
		RESULT = p;
	:}
	;


const_map_value ::=
	explicit_value:e COLON explicit_value:e1
	{:
		types.log("[CUP]: explicit_value COLON explicit_value ");
		const_map_value_node p = new const_map_value_node();
		p.m_k = (syntree_node)e;
		p.m_v = (syntree_node)e1;
		RESULT = p;
	:}
	;

const_array_list_value ::=
	/* empty */
	{:
		types.log("[CUP]: empty ");
		const_array_list_value_node p = new const_array_list_value_node();
		RESULT = p;
	:}
	|
	explicit_value:e
	{:
		types.log("[CUP]: explicit_value ");
		const_array_list_value_node p = new const_array_list_value_node();
		p.add_ele((explicit_value_node)e);
		RESULT = p;
	:}
	|
	const_array_list_value:e explicit_value:e1
	{:
		types.log("[CUP]: const_array_list_value explicit_value ");
		const_array_list_value_node p = (const_array_list_value_node)e;
		p.add_ele((explicit_value_node)e1);
		RESULT = p;
	:}
	;
	