package fakescript;

import java_cup.runtime.*;
import fakescript.syntree.*;

parser code {:
  private mycup m_mycup;
  public void set_mycup(mycup mc)
  {
	m_mycup = mc;
  }
:};

/* Terminals (tokens returned by the scanner). */
terminal VAR_BEGIN;
terminal RETURN;
terminal BREAK;
terminal FUNC;
terminal WHILE;
terminal FTRUE;
terminal FFALSE;
terminal IF;
terminal THEN;
terminal ELSE;
terminal END;
terminal STRING_DEFINITION;
terminal IDENTIFIER;
terminal NUMBER;
terminal SINGLE_LINE_COMMENT;
terminal DIVIDE_MOD;
terminal ARG_SPLITTER;
terminal PLUS;
terminal MINUS;
terminal DIVIDE;
terminal MULTIPLY;
terminal ASSIGN;
terminal MORE;
terminal LESS;
terminal MORE_OR_EQUAL;
terminal LESS_OR_EQUAL;
terminal EQUAL;
terminal NOT_EQUAL;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal AND;
terminal OR;
terminal FKFLOAT;
terminal PLUS_ASSIGN, MINUS_ASSIGN, DIVIDE_ASSIGN, MULTIPLY_ASSIGN, DIVIDE_MOD_ASSIGN;
terminal COLON;
terminal FOR;
terminal INC;
terminal FAKE;
terminal FKUUID;
terminal OPEN_SQUARE_BRACKET;
terminal CLOSE_SQUARE_BRACKET;
terminal FCONST;
terminal PACKAGE;
terminal INCLUDE;
terminal IDENTIFIER_DOT;
terminal IDENTIFIER_POINTER;
terminal STRUCT;
terminal IS, NOT, CONTINUE;
terminal YIELD, SLEEP;
terminal SWITCH, CASE, DEFAULT;
terminal NEW_ASSIGN;
terminal ELSEIF;
terminal RIGHT_POINTER;
terminal STRING_CAT;
terminal OPEN_BIG_BRACKET;
terminal CLOSE_BIG_BRACKET;

/* Non-terminals */
non terminal program;
non terminal break, continue;
non terminal function_declaration;
non terminal block;
non terminal stmt;
non terminal while_stmt;
non terminal else_stmt;
non terminal elseif_stmt;
non terminal elseif_stmt_list;
non terminal if_stmt;
non terminal cmp;
non terminal body;
non terminal return_stmt;
non terminal return_value;
non terminal return_value_list;
non terminal explicit_value;
non terminal variable;
non terminal arg_expr;
non terminal expr;
non terminal math_expr;
non terminal function_call;
non terminal var;
non terminal arg;
non terminal function_call_arguments;
non terminal function_declaration_arguments;
non terminal assign_stmt;
non terminal cmp_value;
non terminal assign_value;
non terminal expr_value;
non terminal math_assign_stmt;
non terminal for_stmt;
non terminal for_loop_stmt;
non terminal multi_assign_stmt;
non terminal var_list;
non terminal fake_call_stmt;
non terminal struct_mem_declaration, struct_head, struct_define;
non terminal sleep;
non terminal yield;
non terminal switch_stmt;
non terminal switch_case_define;
non terminal switch_case_list;
non terminal const_map_list_value;
non terminal const_map_value;
non terminal const_array_list_value;
non terminal package_head, include_define, include_head;
non terminal const_head, const_define;

/* Precedences */
precedence left PLUS, MINUS;
precedence left DIVIDE, MULTIPLY, DIVIDE_MOD;
precedence left STRING_CAT;

/* Top level rules */
program ::= package_head
	include_head
	struct_head
	const_head
	;
	
package_head ::=
	/* empty */
	{:
	:}
	|
	PACKAGE IDENTIFIER:e
	{:
		types.log("[CUP]: PACKAGE IDENTIFIER " + e);
		m_mycup.set_package(e.toString());
	:}
	|
	PACKAGE IDENTIFIER_DOT:e
	{:
		types.log("[CUP]: PACKAGE IDENTIFIER_DOT " + e);
		m_mycup.set_package(e.toString());
	:}
	;

include_head ::=
	/* empty */
	{:
	:}
	|
	include_define
	|
	include_head include_define
	;
	
include_define ::=
	INCLUDE STRING_DEFINITION:e
	{:
		types.log("[CUP]: INCLUDE STRING_DEFINITION " + e);
		m_mycup.add_include(e.toString());
	:}
	;

struct_head ::=
	/* empty */
	{:
	:}
	|
	struct_define
	|
	struct_head struct_define
	;

struct_define ::=
	STRUCT IDENTIFIER:e struct_mem_declaration END
	{:
		types.log("[CUP]: STRUCT IDENTIFIER struct_mem_declaration END ");
		m_mycup.add_struct_desc(e.toString());
	:}
	;
	
struct_mem_declaration ::=
	struct_mem_declaration IDENTIFIER:e
	{:
		types.log("[CUP]: struct_mem_declaration IDENTIFIER ");
	:}
	| 
	IDENTIFIER:e
	{:
		types.log("[CUP]: IDENTIFIER ");
	:}
	;

const_head ::=
	/* empty */
	{:
	:}
	|
	const_define
	|
	const_head const_define
	;

const_define ::=
	FCONST IDENTIFIER:e ASSIGN explicit_value:e1
	{:
		types.log("[CUP]: FCONST IDENTIFIER ASSIGN explicit_value ");
		m_mycup.add_const_desc(e.toString(), (syntree_node)e1);
	:}
	;

explicit_value ::=
	FTRUE:e
	{:
		types.log("[CUP]: FTRUE ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_TRUE;
		RESULT = p;
	:}
	|
	FFALSE:e
	{:
		types.log("[CUP]: FFALSE ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_FALSE;
		RESULT = p;
	:}
	|
	NUMBER:e 
	{:
		types.log("[CUP]: NUMBER ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_NUM;
		RESULT = p;
	:}
	|
	FKUUID:e
	{:
		types.log("[CUP]: FKUUID ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_UUID;
		RESULT = p;
	:}
	|
	STRING_DEFINITION:e 
	{:
		types.log("[CUP]: STRING_DEFINITION ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_STR;
		RESULT = p;
	:}
	|
	FKFLOAT:e
	{:
		types.log("[CUP]: FKFLOAT ");
		explicit_value_node p = new explicit_value_node();
		p.m_str = e.toString();
		p.m_type = explicit_value_type.EVT_FLOAT;
		RESULT = p;
	:}
	|
	OPEN_BIG_BRACKET const_map_list_value:e CLOSE_BIG_BRACKET
	{:
		types.log("[CUP]: OPEN_BIG_BRACKET const_map_list_value CLOSE_BIG_BRACKET ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_MAP;
		p.m_v = (const_map_list_value_node)e;
		RESULT = p;
	:}
	|
	OPEN_SQUARE_BRACKET const_array_list_value:e CLOSE_SQUARE_BRACKET
	{:
		types.log("[CUP]: OPEN_BIG_BRACKET const_array_list_value CLOSE_BIG_BRACKET ");
		explicit_value_node p = new explicit_value_node();
		p.m_type = explicit_value_type.EVT_ARRAY;
		p.m_v = (const_array_list_value_node)e;
		RESULT = p;
	:}
	;
 

const_map_list_value ::=
	/* empty */
	{:
		types.log("[CUP]: empty ");
		const_map_list_value_node p = new const_map_list_value_node();
		RESULT = p;
	:}
	|
	const_map_value:e
	{:
		types.log("[CUP]: const_map_value ");
		const_map_list_value_node p = new const_map_list_value_node();
		p.add_ele((const_map_value_node)e);
		RESULT = p;
	:}
	|
	const_map_list_value:e const_map_value:e1
	{:
		types.log("[CUP]: const_map_list_value const_map_value ");
		const_map_list_value_node p = (const_map_list_value_node)e;
		p.add_ele((const_map_value_node)e1);
		RESULT = p;
	:}
	;


const_map_value ::=
	explicit_value:e COLON explicit_value:e1
	{:
		types.log("[CUP]: explicit_value COLON explicit_value ");
		const_map_value_node p = new const_map_value_node();
		p.m_k = (syntree_node)e;
		p.m_v = (syntree_node)e1;
		RESULT = p;
	:}
	;

const_array_list_value ::=
	/* empty */
	{:
		types.log("[CUP]: empty ");
		const_array_list_value_node p = new const_array_list_value_node();
		RESULT = p;
	:}
	|
	explicit_value:e
	{:
		types.log("[CUP]: explicit_value ");
		const_array_list_value_node p = new const_array_list_value_node();
		p.add_ele((explicit_value_node)e);
		RESULT = p;
	:}
	|
	const_array_list_value:e explicit_value:e1
	{:
		types.log("[CUP]: const_array_list_value explicit_value ");
		const_array_list_value_node p = (const_array_list_value_node)e;
		p.add_ele((explicit_value_node)e1);
		RESULT = p;
	:}
	;
	